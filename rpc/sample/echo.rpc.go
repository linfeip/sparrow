// Code generated by pbgen.
// DO NOT EDIT!!!
// source:  echo.proto

package sample

import (
	"bytes"
	"context"
	"crypto/tls"
	"io"
	"net"
	"net/http"

	"golang.org/x/net/http2"
	"google.golang.org/protobuf/proto"
	"sparrow/logger"
	"sparrow/registry"
	"sparrow/rpc"
)

type Error interface {
	error
	Code() int32
}

type serviceErr struct {
	err  error
	code int32
}

func (e *serviceErr) Error() string {
	return e.err.Error()
}

func (e *serviceErr) Code() int32 {
	return e.code
}

func NewError(code int32, err error) Error {
	return &serviceErr{err: err, code: code}
}

type EchoService interface {
	Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error)
}

func BuildEchoServiceInfo(service EchoService) *rpc.ServiceInfo {
	serviceInfo := &rpc.ServiceInfo{
		ServiceName: "sample.EchoService",
	}
	serviceInfo.Methods = append(serviceInfo.Methods, &rpc.MethodInfo{
		MethodName: "Echo",
		Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			data, err := io.ReadAll(r.Body)
			if err != nil {
				writeError(w, err)
				return
			}

			var req = &EchoRequest{}
			if err = proto.Unmarshal(data, req); err != nil {
				writeError(w, err)
				return
			}

			var rsp *EchoResponse
			rsp, err = service.Echo(r.Context(), req)
			if err != nil {
				writeError(w, err)
				return
			}

			rBytes, err := proto.Marshal(rsp)
			if err != nil {
				writeError(w, err)
				return
			}

			_, _ = w.Write(rBytes)
		}),
	})
	return serviceInfo
}

func writeError(w http.ResponseWriter, err error) {
	switch e := err.(type) {
	case Error:
		w.WriteHeader(int(e.Code()))
	default:
		w.WriteHeader(http.StatusInternalServerError)
	}
	w.Header().Set("SparrowError", err.Error())
}

var client = &http.Client{
	Transport: &http2.Transport{
		AllowHTTP: true,
		DialTLSContext: func(_ context.Context, network, addr string, _ *tls.Config) (net.Conn, error) {
			return net.Dial(network, addr)
		},
	},
}

type EchoServiceClient struct {
	Discover registry.Discover
}

func (e *EchoServiceClient) Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error) {
	data, err := proto.Marshal(request)
	if err != nil {
		return nil, err
	}

	node, err := e.Discover.Select(ctx, "sample.EchoService")
	if err != nil {
		return nil, err
	}

	addr := node.Address
	logger.Debugf("select node: %s", addr)
	httpRequest, err := http.NewRequest(http.MethodPost, "http://"+addr+"/sample.EchoService/Echo", bytes.NewReader(data))
	if err != nil {
		return nil, err
	}

	rsp, err := client.Do(httpRequest)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	rBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}

	var reply = &EchoResponse{}
	err = proto.Unmarshal(rBytes, reply)
	if err != nil {
		return nil, err
	}

	return reply, nil
}
