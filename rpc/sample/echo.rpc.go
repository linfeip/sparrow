// Code generated by pbgen.
// DO NOT EDIT!!!
// source:  echo.proto

package sample

import (
	"bytes"
	"context"
	"crypto/tls"
	"errors"
	"io"
	"net"
	"net/http"

	"golang.org/x/net/http2"
	"google.golang.org/protobuf/proto"
	"sparrow/logger"
	"sparrow/registry"
	"sparrow/rpc"
)

type EchoService interface {
	Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error)
}

type xEchoService struct {
	internal EchoService
}

func (x *xEchoService) Invoke(ctx context.Context, req *rpc.Request) *rpc.Response {
	switch req.Method.MethodName {
	case "Echo":
		reply, err := x.internal.Echo(ctx, req.Input.(*EchoRequest))
		return &rpc.Response{
			Message: reply,
			Error:   rpc.WrapError(err),
		}
	default:
		return &rpc.Response{
			Error: rpc.NewError(404, errors.New("method not found")),
		}
	}
}

func BuildEchoServiceInfo(service EchoService) *rpc.ServiceInfo {
	xxxService := &xEchoService{
		internal: service,
	}
	serviceInfo := &rpc.ServiceInfo{
		ServiceName: "sample.EchoService",
	}
	serviceInfo.Methods = append(serviceInfo.Methods, &rpc.MethodInfo{
		ServiceName: "sample.EchoService",
		MethodName:  "Echo",
		Handler:     xxxService,
		NewInput: func() any {
			return &EchoRequest{}
		},
		NewOutput: func() any {
			return &EchoRequest{}
		},
	})
	return serviceInfo
}

var client = &http.Client{
	Transport: &http2.Transport{
		AllowHTTP: true,
		DialTLSContext: func(_ context.Context, network, addr string, _ *tls.Config) (net.Conn, error) {
			return net.Dial(network, addr)
		},
	},
}

type EchoServiceClient struct {
	Discover registry.Discover
}

func (e *EchoServiceClient) Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error) {
	data, err := proto.Marshal(request)
	if err != nil {
		return nil, err
	}

	node, err := e.Discover.Select(ctx, "sample.EchoService")
	if err != nil {
		return nil, err
	}

	addr := node.Address
	logger.Debugf("select node: %s", addr)
	httpRequest, err := http.NewRequest(http.MethodPost, "http://"+addr+"/sample.EchoService/Echo", bytes.NewReader(data))
	if err != nil {
		return nil, err
	}

	rsp, err := client.Do(httpRequest)
	if err != nil {
		return nil, err
	}
	defer rsp.Body.Close()

	rBytes, err := io.ReadAll(rsp.Body)
	if err != nil {
		return nil, err
	}

	var reply = &EchoResponse{}
	err = proto.Unmarshal(rBytes, reply)
	if err != nil {
		return nil, err
	}

	return reply, nil
}
