// Code generated by pbgen.
// DO NOT EDIT!!!
// source:  echo.proto

package sample

import (
	"context"
	"errors"

	"google.golang.org/protobuf/proto"
	"sparrow/rpc"
	"sparrow/rpc/middleware"
)

type EchoService interface {
	Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error)
}

type xEchoService struct {
	internal EchoService
}

func (x *xEchoService) Invoke(ctx context.Context, req *rpc.Request, callback rpc.CallbackFunc) {
	switch req.Method.MethodName {
	case "Echo":
		reply, err := x.internal.Echo(ctx, req.Input.(*EchoRequest))
		callback(&rpc.Response{
			Message: reply,
			Error:   rpc.WrapError(err),
		})
	default:
		callback(&rpc.Response{
			Error: rpc.NewError(404, errors.New("method not found")),
		})
	}
}

func BuildEchoServiceInfo(service EchoService) *rpc.ServiceInfo {
	xxxService := &xEchoService{
		internal: service,
	}
	invokerChain := rpc.NewInvokerChain(xxxService)
	invokerChain.AddLast(new(middleware.AccessLog))
	invokerChain.AddLast(new(middleware.Skip))
	invokerChain.AddLast(&middleware.DebugInter{Name: "123"})
	EchoServiceEcho.Invoker = invokerChain
	return EchoServiceInfo
}

var EchoServiceInfo = &rpc.ServiceInfo{
	ServiceName: "sample.EchoService",
	Methods: []*rpc.MethodInfo{
		EchoServiceEcho,
	},
}

var EchoServiceEcho = &rpc.MethodInfo{
	ServiceName: "sample.EchoService",
	MethodName:  "Echo",
	NewInput: func() proto.Message {
		return &EchoRequest{}
	},
	NewOutput: func() proto.Message {
		return &EchoResponse{}
	},
}

type SEchoServiceClient struct {
	Invoker rpc.Invoker
}

func (e *SEchoServiceClient) Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error) {
	rpcRequest := &rpc.Request{
		Method: EchoServiceEcho,
		Input:  request,
	}
	var resp *rpc.Response
	e.Invoker.Invoke(ctx, rpcRequest, func(response *rpc.Response) {
		resp = response
	})

	if resp.Error != nil {
		return nil, resp.Error
	}
	return resp.Message.(*EchoResponse), nil
}
