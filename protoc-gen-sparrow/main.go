package main

import (
	"bytes"
	"flag"
	"html/template"
	"strings"

	"github.com/Masterminds/sprig"
	"github.com/huandu/xstrings"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet
	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(
		func(plugin *protogen.Plugin) error {
			plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
			return codegen(plugin)
		},
	)
}

func codegen(plugin *protogen.Plugin) error {
	for _, file := range plugin.Files {
		if !file.Generate {
			continue
		}
		filename := file.GeneratedFilenamePrefix + ".srpc.go"
		g := plugin.NewGeneratedFile(filename, file.GoImportPath)

		tpl, err := template.New("sparrow").Funcs(FuncMap()).Parse(sparrowTmp)
		if err != nil {
			return err
		}

		var data = &FileProto{
			FileDescriptorProto: file.Proto,
			Attrs:               make(Attrs),
		}

		for _, s := range file.Proto.Service {
			service := &Service{
				ServiceDescriptorProto: s,
				Attrs:                  make(Attrs),
			}
			for _, m := range s.GetMethod() {
				method := &Method{
					MethodDescriptorProto: m,
					Attrs:                 make(Attrs),
				}
				if len(m.GetInputType()) > 0 {
					lastIdx := strings.LastIndexByte(m.GetInputType(), '.')
					if lastIdx >= 0 {
						inputType := m.GetInputType()[lastIdx+1:]
						method.InputTypeName = inputType
					}
				}
				if len(m.GetOutputType()) > 0 {
					lastIdx := strings.LastIndexByte(m.GetOutputType(), '.')
					if lastIdx >= 0 {
						outType := m.GetOutputType()[lastIdx+1:]
						method.OutputTypeName = outType
					}
				}

				service.Method = append(service.Method, method)
			}
			data.Service = append(data.Service, service)
		}

		var buffer bytes.Buffer
		err = tpl.Execute(&buffer, data)
		if err != nil {
			return err
		}

		_, err = g.Write(buffer.Bytes())
		return err
	}
	return nil
}

func FuncMap() template.FuncMap {
	fm := sprig.FuncMap()
	fm["camelcase"] = xstrings.ToPascalCase
	return fm
}

type Attrs map[string]any

type FileProto struct {
	*descriptorpb.FileDescriptorProto
	Attrs
	Service []*Service
}

type Service struct {
	*descriptorpb.ServiceDescriptorProto
	Attrs
	Method []*Method
}

type Method struct {
	*descriptorpb.MethodDescriptorProto
	Attrs
	InputTypeName  string
	OutputTypeName string
}

var sparrowTmp = `
// Code generated by protoc-gen-sparrow.
// DO NOT EDIT!!!
// source:  {{.Name}}


{{- $package := .Package}}
package {{$package}}

import (
	"context"
	"errors"

	"google.golang.org/protobuf/proto"
	"sparrow/rpc"
)

{{- range .Service}}
	{{- $_ := set .Attrs "Name" (camelcase .Name)}}
    {{- $service := .}}

    {{- $methods := list}}
	{{- range .Method}}
        {{- $_ = set .Attrs "Name" (camelcase .Name)}}
        {{- $method := printf "%s%sMethodInfo" $service.Attrs.Name .Attrs.Name}}
        var {{$method}} = &rpc.MethodInfo{
            ServiceName: "{{$package}}.{{$service.Attrs.Name}}",
            MethodName:  "{{.Attrs.Name}}",
            NewInput: func() proto.Message {
                return &{{.InputTypeName}}{}
            },
            NewOutput: func() proto.Message {
                return &{{.OutputTypeName}}{}
            },
        }
        {{- $methods = append $methods $method}}
    {{- end}}

	var {{.Attrs.Name}}ServiceInfo = &rpc.ServiceInfo{
		ServiceName: "sample.EchoService",
		Methods: []*rpc.MethodInfo{
            {{- range $methods}}
                {{.}},
            {{- end}}
		},
	}

	func New{{.Attrs.Name}}(impl {{.Attrs.Name}}) rpc.ServiceInvoker {
		return &xxx{{.Attrs.Name}}{
			impl: impl,
		}
	}

	type xxx{{.Attrs.Name}} struct {
		impl {{.Attrs.Name}}
	}

    func (x *xxx{{.Attrs.Name}}) Invoke(ctx context.Context, req *rpc.Request, callback rpc.CallbackFunc) {
        switch req.Method.MethodName {
            {{- range .Method}}
            case "{{.Attrs.Name}}":
            reply, err := x.impl.{{.Attrs.Name}}(ctx, req.Input.(*{{.InputTypeName}}))
            callback(&rpc.Response{
                Message: reply,
                Error:   rpc.WrapError(err),
            })
            {{- end}}
            default:
            callback(&rpc.Response{
                Error: rpc.NewError(404, errors.New("method not found")),
            })
        }
    }

    func (x *xxx{{.Attrs.Name}}) ServiceInfo() *rpc.ServiceInfo {
        return {{.Attrs.Name}}ServiceInfo
    }

	type {{.Attrs.Name}} interface {
		{{- range .Method}}
			{{camelcase .Name}}(ctx context.Context, request *{{.InputTypeName}}) (*{{.OutputTypeName}}, error)
		{{- end}}
	}


    func New{{.Attrs.Name}}Client(client *rpc.Client) {{.Attrs.Name}} {
        return &{{.Attrs.Name}}Client{
            client: client,
        }
    }

    type {{.Attrs.Name}}Client struct {
        client *rpc.Client
    }

    {{- range .Method}}
    func (e *{{$service.Attrs.Name}}Client) {{.Attrs.Name}}(ctx context.Context, request *{{.InputTypeName}}) (*{{.OutputTypeName}}, error) {
        rpcRequest := &rpc.Request{
            Method: {{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo,
            Input:  request,
        }
        var resp *rpc.Response
        e.client.Invoke(ctx, rpcRequest, func(response *rpc.Response) {
            resp = response
        })
        if resp.Error != nil {
            return nil, resp.Error
        }
        return resp.Message.(*{{.OutputTypeName}}), nil
    }
    {{- end}}
{{- end}}
`
