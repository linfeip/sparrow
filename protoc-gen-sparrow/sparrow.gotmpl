// Code generated by protoc-gen-sparrow.
// DO NOT EDIT!!!
// source:  {{.Name}}


{{- $package := .Package}}
package {{$package}}

import (
"context"
"errors"

"google.golang.org/protobuf/proto"
"sparrow/rpc"
)

var _ = rpc.CallType_Unary
var _ = proto.Error

{{- range .Service}}
    {{- $_ := set .Attrs "Name" (camelcase .Name)}}
    {{- $service := .}}

    {{- $methods := list}}
    {{- range .Method}}
        {{- $_ = set .Attrs "Name" (camelcase .Name)}}
        {{- $method := printf "%s%sMethodInfo" $service.Attrs.Name .Attrs.Name}}
        var {{$method}} = &rpc.MethodInfo{
        ServiceName: "{{$package}}.{{$service.Attrs.Name}}",
        MethodName:  "{{.Attrs.Name}}",
        Route: "/{{$service.Attrs.Name}}/{{.Attrs.Name}}",
        CallType: rpc.CallType_{{.CallType}},
        NewInput: func() proto.Message {
        return &{{.InputTypeName}}{}
        },
        NewOutput: func() proto.Message {
        return &{{.OutputTypeName}}{}
        },
        }
        {{- $methods = append $methods $method}}
    {{- end}}

    var {{.Attrs.Name}}ServiceInfo = &rpc.ServiceInfo{
    ServiceName: "sample.EchoService",
    Methods: map[string]*rpc.MethodInfo{
    {{- range $methods}}
        {{.}}.Route: {{.}},
    {{- end}}
    },
    }

    func New{{.Attrs.Name}}Server(impl {{.Attrs.Name}}Server) rpc.ServiceInvoker {
    return &{{untitle .Attrs.Name}}Server{
    impl: impl,
    }
    }

    type {{.Attrs.Name}}Server interface {
    {{- range .Method}}
        {{- if eq .CallType "Unary"}}
            {{camelcase .Name}}(ctx context.Context, request *{{.InputTypeName}}) (*{{.OutputTypeName}}, error)
        {{- else if eq .CallType "BidiStream"}}
            {{camelcase .Name}}(ctx context.Context, stream {{$service.Attrs.Name}}{{.Attrs.Name}}ServerBidiStream) error
        {{- else if eq .CallType "ClientStream"}}
            {{camelcase .Name}}(ctx context.Context, stream {{$service.Attrs.Name}}{{.Attrs.Name}}ServerClientStream) (*{{.OutputTypeName}}, error)
        {{- else if eq .CallType "ServerStream"}}
            {{camelcase .Name}}(ctx context.Context, request *{{.InputTypeName}}, stream {{$service.Attrs.Name}}{{.Attrs.Name}}ServerServerStream) error
        {{- end}}
    {{- end}}
    }

    type {{untitle .Attrs.Name}}Server struct {
    impl {{.Attrs.Name}}Server
    }

    func (x *{{untitle .Attrs.Name}}Server) Invoke(ctx context.Context, req *rpc.Request, callback rpc.CallbackFunc) {
    {{- $server := untitle .Attrs.Name}}
    switch req.Method.MethodName {
    {{- range .Method}}
        case "{{.Attrs.Name}}":
        {{- if eq .CallType "Unary"}}
            reply, err := x.impl.{{.Attrs.Name}}(ctx, req.Input.(*{{.InputTypeName}}))
            callback(&rpc.Response{
            Message: reply,
            Error:   rpc.WrapError(err),
            })
        {{- else if eq .CallType "BidiStream"}}
            err := x.impl.{{.Attrs.Name}}(ctx, &{{$server}}{{.Attrs.Name}}ServerBidiStream{
            stream: req.Stream,
            })
            callback(&rpc.Response{Error: rpc.WrapError(err)})
        {{- else if eq .CallType "ClientStream"}}
            reply, err := x.impl.{{.Attrs.Name}}(ctx, &{{$server}}{{.Attrs.Name}}ServerClientStream{
            stream: req.Stream,
            })
            callback.Response(reply, rpc.WrapError(err))
        {{- else if eq .CallType "ServerStream"}}
            err := x.impl.ServerStream(ctx, req.Input.(*{{.InputTypeName}}), &{{$server}}{{.Attrs.Name}}ServerServerStream{stream: req.Stream})
            callback.Error(rpc.WrapError(err))
        {{- end }}
    {{- end}}
    default:
    callback(&rpc.Response{
    Error: rpc.NewError(404, errors.New("method not found")),
    })
    }
    }

    {{- range .Method}}
        {{- if eq .CallType "BidiStream"}}
            type {{$service.Attrs.Name}}{{.Attrs.Name}}ServerBidiStream interface {
            Send(msg *{{.OutputTypeName}}) error
            Recv() (*{{.InputTypeName}}, error)
            }
            type {{untitle $service.Attrs.Name}}{{.Attrs.Name}}ServerBidiStream struct {
            stream *rpc.BidiStream
            }
            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ServerBidiStream) Send(msg *{{.OutputTypeName}}) error {
            return e.stream.Send(msg)
            }

            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ServerBidiStream) Recv() (*{{.InputTypeName}}, error) {
            reply, err := e.stream.Recv({{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo.NewInput)
            if err != nil {
            return nil, err
            }
            return reply.(*{{.InputTypeName}}), nil
            }
        {{- else if eq .CallType "ClientStream"}}
            type {{$service.Attrs.Name}}{{.Attrs.Name}}ServerClientStream interface {
            Recv() (*{{.InputTypeName}}, error)
            }
            type {{untitle $service.Attrs.Name}}{{.Attrs.Name}}ServerClientStream struct {
            stream *rpc.BidiStream
            }
            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ServerClientStream) Recv() (*{{.InputTypeName}}, error) {
            reply, err := e.stream.Recv({{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo.NewInput)
            if err != nil {
            return nil, err
            }
            return reply.(*{{.InputTypeName}}), nil
            }
        {{- else if eq .CallType "ServerStream"}}
            type {{$service.Attrs.Name}}{{.Attrs.Name}}ServerServerStream interface {
            Send(msg *{{.OutputTypeName}}) error
            }
            type {{untitle $service.Attrs.Name}}{{.Attrs.Name}}ServerServerStream struct {
            stream *rpc.BidiStream
            }
            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ServerServerStream) Send(msg *{{.OutputTypeName}}) error {
            return e.stream.Send(msg)
            }
        {{- end}}
    {{- end}}

    func (x *{{untitle .Attrs.Name}}Server) ServiceInfo() *rpc.ServiceInfo {
    return {{.Attrs.Name}}ServiceInfo
    }

    func New{{.Attrs.Name}}Client(client *rpc.Client) {{.Attrs.Name}}Client {
    return &{{untitle .Attrs.Name}}Client{
    client: client,
    }
    }

    type {{.Attrs.Name}}Client interface {
    {{- range .Method}}
        {{- if eq .CallType "Unary"}}
            {{.Attrs.Name}}(ctx context.Context, request *{{.InputTypeName}}) (*{{.OutputTypeName}}, error)
        {{- else if eq .CallType "BidiStream"}}
            {{.Attrs.Name}}(ctx context.Context) ({{$service.Attrs.Name}}{{.Attrs.Name}}ClientBidiStream, error)
        {{- else if eq .CallType "ClientStream"}}
            {{.Attrs.Name}}(ctx context.Context) ({{$service.Attrs.Name}}{{.Attrs.Name}}ClientClientStream, error)
        {{- else if eq .CallType "ServerStream"}}
            {{.Attrs.Name}}(ctx context.Context, request *{{.InputTypeName}}) ({{$service.Attrs.Name}}{{.Attrs.Name}}ClientServerStream, error)
        {{- end}}
    {{- end}}
    }

    type {{untitle .Attrs.Name}}Client struct {
    client *rpc.Client
    }

    {{- range .Method}}
        {{- if eq .CallType "Unary"}}
            func (e *{{untitle $service.Attrs.Name}}Client) {{.Attrs.Name}}(ctx context.Context, request *{{.InputTypeName}}) (*{{.OutputTypeName}}, error) {
            rpcRequest := &rpc.Request{
            Method: {{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo,
            Input:  request,
            }
            var resp *rpc.Response
            e.client.Invoke(ctx, rpcRequest, func(response *rpc.Response) {
            resp = response
            })
            if resp.Error != nil {
            return nil, resp.Error
            }
            return resp.Message.(*{{.OutputTypeName}}), nil
            }
        {{- else if eq .CallType "BidiStream"}}

            type {{$service.Attrs.Name}}{{.Attrs.Name}}ClientBidiStream interface {
            Send(*{{.InputTypeName}}) error
            Recv() (*{{.OutputTypeName}}, error)
            }

            type {{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientBidiStream struct {
            stream *rpc.BidiStream
            }

            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientBidiStream) Send(msg *{{.InputTypeName}}) error {
            return e.stream.Send(msg)
            }

            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientBidiStream) Recv() (*{{.OutputTypeName}}, error) {
            reply, err := e.stream.Recv({{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo.NewOutput)
            if err != nil {
            return nil, err
            }
            return reply.(*{{.OutputTypeName}}), nil
            }

            func (e *{{untitle $service.Attrs.Name}}Client) {{.Attrs.Name}}(ctx context.Context) ({{$service.Attrs.Name}}{{.Attrs.Name}}ClientBidiStream, error) {
            req := &rpc.Request{
            Method: {{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo,
            }
            stream, err := e.client.OpenStream(ctx, req)
            if err != nil {
            return nil, err
            }
            return &{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientBidiStream{stream: stream}, nil
            }
        {{- else if eq .CallType "ClientStream"}}

            type {{$service.Attrs.Name}}{{.Attrs.Name}}ClientClientStream interface {
            Send(msg *{{.InputTypeName}}) error
            CloseAndRecv() (*{{.OutputTypeName}}, error)
            }

            type {{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientClientStream struct {
            stream *rpc.BidiStream
            }

            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientClientStream) Send(msg *{{.InputTypeName}}) error {
            return e.stream.Send(msg)
            }

            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientClientStream) CloseAndRecv() (*{{.OutputTypeName}}, error) {
            msg, err := e.stream.CloseAndRecv()
            if err != nil {
            return nil, err
            }
            return msg.(*{{.OutputTypeName}}), nil
            }

            func (e *{{untitle $service.Attrs.Name}}Client) {{.Attrs.Name}}(ctx context.Context) ({{$service.Attrs.Name}}{{.Attrs.Name}}ClientClientStream, error) {
            req := &rpc.Request{
            Method: {{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo,
            }
            stream, err := e.client.OpenStream(ctx, req)
            if err != nil {
            return nil, err
            }
            return &{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientClientStream{stream: stream}, nil
            }
        {{- else  if eq .CallType "ServerStream"}}

            type {{$service.Attrs.Name}}{{.Attrs.Name}}ClientServerStream interface {
            Recv() (*{{.OutputTypeName}}, error)
            }

            type {{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientServerStream struct {
            stream *rpc.BidiStream
            }

            func (e *{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientServerStream) Recv() (*{{.OutputTypeName}}, error) {
            msg, err := e.stream.Recv({{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo.NewOutput)
            if err != nil {
            return nil, err
            }
            return msg.(*{{.OutputTypeName}}), nil
            }

            func (e *{{untitle $service.Attrs.Name}}Client) {{.Attrs.Name}}(ctx context.Context, request *{{.InputTypeName}}) ({{$service.Attrs.Name}}{{.Attrs.Name}}ClientServerStream, error) {
            req := &rpc.Request{
            Method: {{$service.Attrs.Name}}{{.Attrs.Name}}MethodInfo,
            Input:  request,
            }
            stream, err := e.client.OpenStream(ctx, req)
            if err != nil {
            return nil, err
            }
            err = stream.Send(request)
            if err != nil {
            return nil, err
            }
            return &{{untitle $service.Attrs.Name}}{{.Attrs.Name}}ClientServerStream{stream: stream}, nil
            }
        {{- end}}
    {{- end}}
{{- end}}