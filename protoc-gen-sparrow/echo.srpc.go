// Code generated by protoc-gen-sparrow.
// DO NOT EDIT!!!
// source:  echo.proto
package main

import (
	"context"
	"errors"

	"google.golang.org/protobuf/proto"
	"sparrow/rpc"
)

var _ = rpc.CallType_Unary
var _ = proto.Error
var EchoServiceEchoMethodInfo = &rpc.MethodInfo{
	ServiceName: "main.EchoService",
	MethodName:  "Echo",
	CallType:    rpc.CallType_Unary,
	NewInput: func() proto.Message {
		return &EchoRequest{}
	},
	NewOutput: func() proto.Message {
		return &EchoResponse{}
	},
}
var EchoServiceIncrMethodInfo = &rpc.MethodInfo{
	ServiceName: "main.EchoService",
	MethodName:  "Incr",
	CallType:    rpc.CallType_Unary,
	NewInput: func() proto.Message {
		return &IncrRequest{}
	},
	NewOutput: func() proto.Message {
		return &IncrResponse{}
	},
}
var EchoServicePubsubMethodInfo = &rpc.MethodInfo{
	ServiceName: "main.EchoService",
	MethodName:  "Pubsub",
	CallType:    rpc.CallType_BidiStream,
	NewInput: func() proto.Message {
		return &PubsubArgs{}
	},
	NewOutput: func() proto.Message {
		return &PubsubReply{}
	},
}
var EchoServiceClientStreamMethodInfo = &rpc.MethodInfo{
	ServiceName: "main.EchoService",
	MethodName:  "ClientStream",
	CallType:    rpc.CallType_ClientStream,
	NewInput: func() proto.Message {
		return &ClientStreamArgs{}
	},
	NewOutput: func() proto.Message {
		return &ClientStreamReply{}
	},
}
var EchoServiceServerStreamMethodInfo = &rpc.MethodInfo{
	ServiceName: "main.EchoService",
	MethodName:  "ServerStream",
	CallType:    rpc.CallType_ServerStream,
	NewInput: func() proto.Message {
		return &ServerStreamArgs{}
	},
	NewOutput: func() proto.Message {
		return &ServerStreamReply{}
	},
}

var EchoServiceServiceInfo = &rpc.ServiceInfo{
	ServiceName: "sample.EchoService",
	Methods: map[string]*rpc.MethodInfo{
		EchoServiceEchoMethodInfo.Route:         EchoServiceEchoMethodInfo,
		EchoServiceIncrMethodInfo.Route:         EchoServiceIncrMethodInfo,
		EchoServicePubsubMethodInfo.Route:       EchoServicePubsubMethodInfo,
		EchoServiceClientStreamMethodInfo.Route: EchoServiceClientStreamMethodInfo,
		EchoServiceServerStreamMethodInfo.Route: EchoServiceServerStreamMethodInfo,
	},
}

func NewEchoServiceServer(impl EchoServiceServer) rpc.ServiceInvoker {
	return &echoServiceServer{
		impl: impl,
	}
}

type EchoServiceServer interface {
	Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error)
	Incr(ctx context.Context, request *IncrRequest) (*IncrResponse, error)
	Pubsub(ctx context.Context, stream EchoServicePubsubServerBidiStream) error
	ClientStream(ctx context.Context, stream EchoServiceClientStreamServerClientStream) (*ClientStreamReply, error)
	ServerStream(ctx context.Context, request *ServerStreamArgs, stream EchoServiceServerStreamServerServerStream) error
}

type echoServiceServer struct {
	impl EchoServiceServer
}

func (x *echoServiceServer) Invoke(ctx context.Context, req *rpc.Request, callback rpc.CallbackFunc) {
	switch req.Method.MethodName {
	case "Echo":
		reply, err := x.impl.Echo(ctx, req.Input.(*EchoRequest))
		callback(&rpc.Response{
			Message: reply,
			Error:   rpc.WrapError(err),
		})
	case "Incr":
		reply, err := x.impl.Incr(ctx, req.Input.(*IncrRequest))
		callback(&rpc.Response{
			Message: reply,
			Error:   rpc.WrapError(err),
		})
	case "Pubsub":
		err := x.impl.Pubsub(ctx, &echoServicePubsubServerBidiStream{
			stream: req.Stream,
		})
		callback(&rpc.Response{Error: rpc.WrapError(err)})
	case "ClientStream":
		reply, err := x.impl.ClientStream(ctx, &echoServiceClientStreamServerClientStream{
			stream: req.Stream,
		})
		callback.Response(reply, rpc.WrapError(err))
	case "ServerStream":
		err := x.impl.ServerStream(ctx, req.Input.(*ServerStreamArgs), &echoServiceServerStreamServerServerStream{stream: req.Stream})
		callback.Error(rpc.WrapError(err))
	default:
		callback(&rpc.Response{
			Error: rpc.NewError(404, errors.New("method not found")),
		})
	}
}

type EchoServicePubsubServerBidiStream interface {
	Send(msg *PubsubReply) error
	Recv() (*PubsubArgs, error)
}
type echoServicePubsubServerBidiStream struct {
	stream *rpc.BidiStream
}

func (e *echoServicePubsubServerBidiStream) Send(msg *PubsubReply) error {
	return e.stream.Send(msg)
}

func (e *echoServicePubsubServerBidiStream) Recv() (*PubsubArgs, error) {
	reply, err := e.stream.Recv(EchoServicePubsubMethodInfo.NewInput)
	if err != nil {
		return nil, err
	}
	return reply.(*PubsubArgs), nil
}

type EchoServiceClientStreamServerClientStream interface {
	Recv() (*ClientStreamArgs, error)
}
type echoServiceClientStreamServerClientStream struct {
	stream *rpc.BidiStream
}

func (e *echoServiceClientStreamServerClientStream) Recv() (*ClientStreamArgs, error) {
	reply, err := e.stream.Recv(EchoServiceClientStreamMethodInfo.NewInput)
	if err != nil {
		return nil, err
	}
	return reply.(*ClientStreamArgs), nil
}

type EchoServiceServerStreamServerServerStream interface {
	Send(msg *ServerStreamReply) error
}
type echoServiceServerStreamServerServerStream struct {
	stream *rpc.BidiStream
}

func (e *echoServiceServerStreamServerServerStream) Send(msg *ServerStreamReply) error {
	return e.stream.Send(msg)
}

func (x *echoServiceServer) ServiceInfo() *rpc.ServiceInfo {
	return EchoServiceServiceInfo
}

func NewEchoServiceClient(client *rpc.Client) EchoServiceClient {
	return &echoServiceClient{
		client: client,
	}
}

type EchoServiceClient interface {
	Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error)
	Incr(ctx context.Context, request *IncrRequest) (*IncrResponse, error)
	Pubsub(ctx context.Context) (EchoServicePubsubClientBidiStream, error)
	ClientStream(ctx context.Context) (EchoServiceClientStreamClientClientStream, error)
	ServerStream(ctx context.Context, request *ServerStreamArgs) (EchoServiceServerStreamClientServerStream, error)
}

type echoServiceClient struct {
	client *rpc.Client
}

func (e *echoServiceClient) Echo(ctx context.Context, request *EchoRequest) (*EchoResponse, error) {
	rpcRequest := &rpc.Request{
		Method: EchoServiceEchoMethodInfo,
		Input:  request,
	}
	var resp *rpc.Response
	e.client.Invoke(ctx, rpcRequest, func(response *rpc.Response) {
		resp = response
	})
	if resp.Error != nil {
		return nil, resp.Error
	}
	return resp.Message.(*EchoResponse), nil
}
func (e *echoServiceClient) Incr(ctx context.Context, request *IncrRequest) (*IncrResponse, error) {
	rpcRequest := &rpc.Request{
		Method: EchoServiceIncrMethodInfo,
		Input:  request,
	}
	var resp *rpc.Response
	e.client.Invoke(ctx, rpcRequest, func(response *rpc.Response) {
		resp = response
	})
	if resp.Error != nil {
		return nil, resp.Error
	}
	return resp.Message.(*IncrResponse), nil
}

type EchoServicePubsubClientBidiStream interface {
	Send(*PubsubArgs) error
	Recv() (*PubsubReply, error)
}

type echoServicePubsubClientBidiStream struct {
	stream *rpc.BidiStream
}

func (e *echoServicePubsubClientBidiStream) Send(msg *PubsubArgs) error {
	return e.stream.Send(msg)
}

func (e *echoServicePubsubClientBidiStream) Recv() (*PubsubReply, error) {
	reply, err := e.stream.Recv(EchoServicePubsubMethodInfo.NewOutput)
	if err != nil {
		return nil, err
	}
	return reply.(*PubsubReply), nil
}

func (e *echoServiceClient) Pubsub(ctx context.Context) (EchoServicePubsubClientBidiStream, error) {
	req := &rpc.Request{
		Method: EchoServicePubsubMethodInfo,
	}
	stream, err := e.client.OpenStream(ctx, req)
	if err != nil {
		return nil, err
	}
	return &echoServicePubsubClientBidiStream{stream: stream}, nil
}

type EchoServiceClientStreamClientClientStream interface {
	Send(msg *ClientStreamArgs) error
	CloseAndRecv() (*ClientStreamReply, error)
}

type echoServiceClientStreamClientClientStream struct {
	stream *rpc.BidiStream
}

func (e *echoServiceClientStreamClientClientStream) Send(msg *ClientStreamArgs) error {
	return e.stream.Send(msg)
}

func (e *echoServiceClientStreamClientClientStream) CloseAndRecv() (*ClientStreamReply, error) {
	msg, err := e.stream.CloseAndRecv()
	if err != nil {
		return nil, err
	}
	return msg.(*ClientStreamReply), nil
}

func (e *echoServiceClient) ClientStream(ctx context.Context) (EchoServiceClientStreamClientClientStream, error) {
	req := &rpc.Request{
		Method: EchoServiceClientStreamMethodInfo,
	}
	stream, err := e.client.OpenStream(ctx, req)
	if err != nil {
		return nil, err
	}
	return &echoServiceClientStreamClientClientStream{stream: stream}, nil
}

type EchoServiceServerStreamClientServerStream interface {
	Recv() (*ServerStreamReply, error)
}

type echoServiceServerStreamClientServerStream struct {
	stream *rpc.BidiStream
}

func (e *echoServiceServerStreamClientServerStream) Recv() (*ServerStreamReply, error) {
	msg, err := e.stream.Recv(EchoServiceServerStreamMethodInfo.NewOutput)
	if err != nil {
		return nil, err
	}
	return msg.(*ServerStreamReply), nil
}

func (e *echoServiceClient) ServerStream(ctx context.Context, request *ServerStreamArgs) (EchoServiceServerStreamClientServerStream, error) {
	req := &rpc.Request{
		Method: EchoServiceServerStreamMethodInfo,
		Input:  request,
	}
	stream, err := e.client.OpenStream(ctx, req)
	if err != nil {
		return nil, err
	}
	err = stream.Send(request)
	if err != nil {
		return nil, err
	}
	return &echoServiceServerStreamClientServerStream{stream: stream}, nil
}
